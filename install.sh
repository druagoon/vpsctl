#!/usr/bin/env bash

# @describe Install a binary release of vpsctl hosted on GitHub
# @meta inherit-flag-options
# @meta require-tools curl,install,mktemp,tar
# @flag   -D --debug                            Enable debug mode
# @flag   -f --force                            Force overwriting an existing binary
# @option    --tag=latest                       Tag (version) of the binary to install
# @option    --bin-dir=/usr/local/bin <DIR>     Where to install the binary

set -eo pipefail

## Color functions
##
## Usage:
## Use any of the functions below to color or format a portion of a string.
##
##   echo "before $(red this is red) after"
##   echo "before $(green_bold this is green_bold) after"
##
## Color output will be disabled if `NO_COLOR` environment variable is set
## in compliance with https://no-color.org/
##
print_in_color() {
    local color="$1"
    shift
    if [[ -z ${NO_COLOR+x} ]]; then
        printf "${color}%b\e[0m\n" "$*"
    else
        printf "%b\n" "$*"
    fi
}
red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# Project metadata
readonly NAME="vpsctl"
readonly URL="https://github.com/druagoon/vpsctl"
readonly REPO="${URL#https://github.com/}"

# Temporary directory for the installation process
temp_dir=""

chomp() { printf "%s" "${1/"$'\n'"/}"; }

oh1() {
    printf "$(green "==>") $(bold "%s")\n" "$*"
}

oh2() {
    printf "$(blue "==>") $(bold "%s")\n" "$*"
}

warn() {
    printf "$(yellow_bold Warning): %s\n" "$(chomp "$1")" >&2
}

error() {
    printf "$(red_bold Error): %s\n" "$(chomp "$1")" >&2
}

fatal() {
    if [[ -n "${temp_dir}" ]]; then
        rm -rf "${temp_dir}"
    fi
    error "$@"
    exit 1
}

need() {
    if ! command -v "$1" >/dev/null 2>&1; then
        err "need $1 (command not found)"
    fi
}

main() {
    oh1 "Installing $(green "${NAME}") from ${URL}"

    local force="${argc_force:-0}"
    local bin_dir="${argc_bin_dir:-/usr/local/bin}"
    local tag="${argc_tag:-latest}"
    if [[ "${tag}" == "latest" ]]; then
        need jq
        tag="$(curl -fsSL "https://api.github.com/repos/${REPO}/releases/latest" | jq -r .tag_name)"
    fi
    local archive="${URL}/releases/download/${tag}/${NAME}-${tag}.tar.gz"

    oh2 "Showing information for $(green "${NAME}") installation"
    echo "Repository:  ${URL}"
    echo "Tag:         ${tag}"
    echo "Name:        ${NAME}"
    echo "Archive:     ${archive}"
    echo "Destination: ${bin_dir}"

    temp_dir="$(mktemp -d || mktemp -d -t tmp)"
    local temp_file="${temp_dir}/${NAME}.tar.gz"
    curl -fsSL -o "${temp_file}" "${archive}"

    oh2 "Extracting ${temp_file} archive to ${temp_dir}"
    tar -C ${temp_dir} -zxvf "${temp_file}"

    local temp_bin_dir="${temp_dir}/bin"
    if [[ ! -d "${temp_bin_dir}" ]]; then
        fatal "No 'bin' directory found in the archive."
    fi

    oh2 "Installing binaries from ${temp_bin_dir} to ${bin_dir}"
    for p in "${temp_bin_dir}"/*; do
        local filename="$(basename "$p")"
        if [[ -e "${bin_dir}/${filename}" ]] && [[ "${force}" == "0" ]]; then
            fatal "${filename} already exists in ${bin_dir}. Use --force dest overwrite."
        else
            install -v -m 755 "$p" "${bin_dir}"
        fi
    done

    oh2 "Cleaning up temporary files"
    rm -rf "${temp_dir}"
}

_argc_before() {
    if [[ "${argc_debug:-}" == "1" ]]; then
        set -x
    fi
}

# ARGC-BUILD {
# This block was generated by argc (https://github.com/sigoden/argc).
# Modifying it manually is not recommended

_argc_run() {
    if [[ "${1:-}" == "___internal___" ]]; then
        _argc_die "error: unsupported ___internal___ command"
    fi
    if [[ "${OS:-}" == "Windows_NT" ]] && [[ -n "${MSYSTEM:-}" ]]; then
        set -o igncr
    fi
    argc__args=("$(basename "$0" .sh)" "$@")
    argc__positionals=()
    _argc_index=1
    _argc_len="${#argc__args[@]}"
    _argc_tools=()
    _argc_parse
    _argc_require_tools "${_argc_tools[@]}"
    _argc_before
    if [ -n "${argc__fn:-}" ]; then
        $argc__fn "${argc__positionals[@]}"
    fi
}

_argc_usage() {
    cat <<-'EOF'
Install a binary release of vpsctl hosted on GitHub

USAGE: install.sh [OPTIONS]

OPTIONS:
  -D, --debug          Enable debug mode
  -f, --force          Force overwriting an existing binary
      --tag <TAG>      Tag (version) of the binary to install [default: latest]
      --bin-dir <DIR>  Where to install the binary [default: /usr/local/bin]
  -h, --help           Print help
  -V, --version        Print version
EOF
    exit
}

_argc_version() {
    echo install.sh 0.0.0
    exit
}

_argc_parse() {
    local _argc_key _argc_action
    local _argc_subcmds=""
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
            --help | -help | -h)
                _argc_usage
                ;;
            --version | -version | -V)
                _argc_version
                ;;
            --)
                _argc_dash="${#argc__positionals[@]}"
                argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
                _argc_index=$_argc_len
                break
                ;;
            --debug | -D)
                if [[ "$_argc_item" == *=* ]]; then
                    _argc_die "error: flag \`--debug\` don't accept any value"
                fi
                _argc_index=$((_argc_index + 1))
                if [[ -n "${argc_debug:-}" ]]; then
                    _argc_die "error: the argument \`--debug\` cannot be used multiple times"
                else
                    argc_debug=1
                fi
                ;;
            --force | -f)
                if [[ "$_argc_item" == *=* ]]; then
                    _argc_die "error: flag \`--force\` don't accept any value"
                fi
                _argc_index=$((_argc_index + 1))
                if [[ -n "${argc_force:-}" ]]; then
                    _argc_die "error: the argument \`--force\` cannot be used multiple times"
                else
                    argc_force=1
                fi
                ;;
            --tag)
                _argc_take_args "--tag <TAG>" 1 1 "-" ""
                _argc_index=$((_argc_index + _argc_take_args_len + 1))
                if [[ -z "${argc_tag:-}" ]]; then
                    argc_tag="${_argc_take_args_values[0]:-}"
                else
                    _argc_die "error: the argument \`--tag\` cannot be used multiple times"
                fi
                ;;
            --bin-dir)
                _argc_take_args "--bin-dir <DIR>" 1 1 "-" ""
                _argc_index=$((_argc_index + _argc_take_args_len + 1))
                if [[ -z "${argc_bin_dir:-}" ]]; then
                    argc_bin_dir="${_argc_take_args_values[0]:-}"
                else
                    _argc_die "error: the argument \`--bin-dir\` cannot be used multiple times"
                fi
                ;;
            *)
                if _argc_maybe_flag_option "-" "$_argc_item"; then
                    _argc_die "error: unexpected argument \`$_argc_key\` found"
                fi
                argc__positionals+=("$_argc_item")
                _argc_index=$((_argc_index + 1))
                ;;
        esac
    done
    _argc_tools=(curl install mktemp tar)
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        argc__fn=main
        if [[ "${argc__positionals[0]:-}" == "help" ]] && [[ "${#argc__positionals[@]}" -eq 1 ]]; then
            _argc_usage
        fi
        if [[ -z "${argc_tag:-}" ]]; then
            argc_tag=latest
        fi
        if [[ -z "${argc_bin_dir:-}" ]]; then
            argc_bin_dir=/usr/local/bin
        fi
    fi
}

_argc_take_args() {
    _argc_take_args_values=()
    _argc_take_args_len=0
    local param="$1" min="$2" max="$3" signs="$4" delimiter="$5"
    if [[ "$min" -eq 0 ]] && [[ "$max" -eq 0 ]]; then
        return
    fi
    local _argc_take_index=$((_argc_index + 1)) _argc_take_value
    if [[ "$_argc_item" == *=* ]]; then
        _argc_take_args_values=("${_argc_item##*=}")
    else
        while [[ $_argc_take_index -lt $_argc_len ]]; do
            _argc_take_value="${argc__args[_argc_take_index]}"
            if _argc_maybe_flag_option "$signs" "$_argc_take_value"; then
                if [[ "${#_argc_take_value}" -gt 1 ]]; then
                    break
                fi
            fi
            _argc_take_args_values+=("$_argc_take_value")
            _argc_take_args_len=$((_argc_take_args_len + 1))
            if [[ "$_argc_take_args_len" -ge "$max" ]]; then
                break
            fi
            _argc_take_index=$((_argc_take_index + 1))
        done
    fi
    if [[ "${#_argc_take_args_values[@]}" -lt "$min" ]]; then
        _argc_die "error: incorrect number of values for \`$param\`"
    fi
    if [[ -n "$delimiter" ]] && [[ "${#_argc_take_args_values[@]}" -gt 0 ]]; then
        local item values arr=()
        for item in "${_argc_take_args_values[@]}"; do
            IFS="$delimiter" read -r -a values <<<"$item"
            arr+=("${values[@]}")
        done
        _argc_take_args_values=("${arr[@]}")
    fi
}

_argc_maybe_flag_option() {
    local signs="$1" arg="$2"
    if [[ -z "$signs" ]]; then
        return 1
    fi
    local cond=false
    if [[ "$signs" == *"+"* ]]; then
        if [[ "$arg" =~ ^\+[^+].* ]]; then
            cond=true
        fi
    elif [[ "$arg" == -* ]]; then
        if ((${#arg} < 3)) || [[ ! "$arg" =~ ^---.* ]]; then
            cond=true
        fi
    fi
    if [[ "$cond" == "false" ]]; then
        return 1
    fi
    local value="${arg%%=*}"
    if [[ "$value" =~ [[:space:]] ]]; then
        return 1
    fi
    return 0
}

_argc_require_tools() {
    local tool missing_tools=()
    for tool in "$@"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            missing_tools+=("$tool")
        fi
    done
    if [[ "${#missing_tools[@]}" -gt 0 ]]; then
        echo "error: missing tools: ${missing_tools[*]}" >&2
        exit 1
    fi
}

_argc_die() {
    if [[ $# -eq 0 ]]; then
        cat
    else
        echo "$*" >&2
    fi
    exit 1
}

_argc_run "$@"

# ARGC-BUILD }
